import numpy as np
from PIL import Image
from collections import Counter
import os

# Minimum file size in bytes, ensures that only large enough files are processed.
# Small files could provide too little data. Size used in the development of the datasets was 1024**2 bytes
MIN_FILE_SIZE = 0
VARIANCE_THRESHOLD = 10
INTENSITY_RANGE_THRESHOLD = 5
# Determines the resolution of output files, 16 by 16 pixels by default
RESCALE_PIXELS=16

# This will help us identify executable files based on their signatures
def is_executable(file_path):
    # Read the first few bytes of the file
    with open(file_path, 'rb') as f:
        header = f.read(4)
    
    # Check for PE (Windows executable) and ELF (Linux executable) magic numbers
    if header[:2] == b'MZ':  # Windows PE
        return True
    elif header[:4] == b'\x7fELF':  # Linux ELF
        return True
    return False

def read_file_in_hex(file_path):
    # Read the .exe file in binary mode
    with open(file_path, 'rb') as f:
        content = f.read()
    # Convert the binary data to a sequence of hexadecimal values
    hex_data = content.hex()
    return hex_data

def calculate_bigram_frequencies(hex_data):
    # Extract bigrams (pairs of consecutive hexadecimal values)
    bigrams = [hex_data[i:i+2] + hex_data[i+2:i+4] for i in range(0, len(hex_data) - 3, 2)]
    
    # Count the frequencies of each bigram
    bigram_counter = Counter(bigrams)
    
    # Initialize a 16x16 grid (256 possible bigrams) for frequency counting
    frequency_grid = np.zeros((16, 16), dtype=int)
    
    # Populate the frequency grid, mapping bigrams to grid coordinates
    for bigram, count in bigram_counter.items():
        # Map the first and second byte of the bigram into the 16x16 grid
        x = int(bigram[:2], 16) // 16  # Map to range 0-15
        y = int(bigram[2:], 16) // 16  # Map to range 0-15
        frequency_grid[x, y] += count
    
    return frequency_grid


# Logarithmic way to normaliez the grid: normalize_grid_log
# this method ensures that the images are being generated with less variance in brightness
def normalize_grid_log(frequency_grid):
    # Add 1 to avoid log(0)
    log_grid = np.log1p(frequency_grid)
    max_value = log_grid.max()
    if max_value == 0:
        return log_grid
    normalized_grid = (log_grid / max_value) * 255
    return normalized_grid.astype(np.uint8)


def generate_image_from_grid(normalized_grid, output_image_path):
    # Create an image from the normalized grid
    img = Image.fromarray(normalized_grid)
    
    # Resize the image for better visualization (optional)
    img = img.resize((RESCALE_PIXELS, RESCALE_PIXELS), Image.NEAREST)
    
    # Save the image
    img.save(output_image_path)
    
def is_image_flat(normalized_grid, variance_threshold=VARIANCE_THRESHOLD, intensity_range_threshold=INTENSITY_RANGE_THRESHOLD):
    # Calculate the variance of pixel intensities
    variance = np.var(normalized_grid)
    
    # Check if variance is below the threshold
    if variance < variance_threshold:
        return True
    
    # Check if the intensity range is too small
    pixel_range = normalized_grid.max() - normalized_grid.min()
    if pixel_range < intensity_range_threshold:
        return True
    
    return False

files_processed_counter = 0

def process_exe_file(
                    exe_file_path, 
                    output_image_path, 
                    min_file_size=MIN_FILE_SIZE, 
                    variance_threshold=VARIANCE_THRESHOLD, 
                    intensity_range_threshold=INTENSITY_RANGE_THRESHOLD, 
                    max_brightness_threshold=240,
                    set_count_limit=False,
                    count_limit=1):
                    
    global files_processed_counter

    # Check the file size first
    file_size = os.path.getsize(exe_file_path)
    if file_size < min_file_size:
        print(f"File {exe_file_path} is too small ({file_size} bytes) and will be skipped.")
        return None  # Skipping the file, no processing done

    # Proceed with the rest of the processing if the file size is above the threshold
    hex_data = read_file_in_hex(exe_file_path)
    frequency_grid = calculate_bigram_frequencies(hex_data)
    normalized_grid = normalize_grid_log(frequency_grid)
    
    # Check if the image is too "flat" or too bright
    if is_image_flat(normalized_grid, variance_threshold, intensity_range_threshold):
        print(f"Image from {exe_file_path} is too flat or too bright and will not be saved.")
        return None  # Skipping the file, no processing done

    # If the image passes the checks, save it
    generate_image_from_grid(normalized_grid, output_image_path)
    print(f"Image saved to {output_image_path}")
    
    # Increment the counter and check if the limit has been reached
    files_processed_counter += 1
    print(f"Files processed: {files_processed_counter}")

    if set_count_limit and files_processed_counter >= count_limit:
        print("Processing limit reached. Stopping.")
        return False  # Stop the loop

    return True  # Continue processing files


# use this function to process a single file, useful for testing and debugging

# input_directory = ""
# output_directory = ""
# process_exe_file(input_directory, output_directory)
